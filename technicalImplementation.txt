âº Perfect! Let me present my proposed architecture for the Doctor Invitation/Sign-Up Flow. Based on the acceptance criteria and the existing authentication patterns, here's what I'm
  considering:

  ğŸ—ï¸ PROPOSED ARCHITECTURE: Doctor Invitation & Sign-Up Flow

  Overview

  Implement a complete user management system where:
  1. Owner registers and creates a clinic/IPRESS
  2. Owner invites doctors via email
  3. Doctor activates account and sets password
  4. Doctor completes clinical profile
  5. Owner validates and activates doctor

  ---
  1. DATABASE SCHEMA (New Tables in DynamoDB)

  Table: Users_Table

  {
    user_id: string;              // PK: UUID
    email: string;                // GSI: email-index (UK)
    password_hash: string;        // Argon2id
    full_name: string;
    role: string;                 // "owner" | "doctor" | "patient"
    status: string;               // "invited" | "incomplete" | "pending" | "active" | "inactive"
    tenant_id: string;            // FK to Tenants_Table, GSI: tenant_id-index
    invite_token?: string;        // Single-use JWT token
    invite_token_expires?: number; // Epoch timestamp
    mfa_enabled: boolean;
    mfa_secret?: string;
    created_at: string;           // ISO timestamp
    updated_at: string;
    last_login?: string;
  }

  Table: Tenants_Table

  {
    tenant_id: string;            // PK: UUID (clinic/IPRESS ID)
    owner_user_id: string;        // FK to Users_Table
    clinic_name: string;
    country: string;              // Locked after setup
    state_region: string;         // Locked after setup
    city: string;                 // Editable
    timezone: string;             // Auto-set, locked
    language: string;             // "es" | "en" | "pt", editable
    status: string;               // "draft" | "incomplete" | "active" | "suspended" | "closed"
    created_at: string;
    updated_at: string;
  }

  Table: Audit_Logs_Table

  {
    log_id: string;               // PK: UUID
    timestamp: string;            // SK: ISO timestamp, GSI for sorting
    user_id: string;              // GSI: user_id-timestamp-index
    tenant_id: string;            // GSI: tenant_id-timestamp-index
    action: string;               // "user.created" | "user.invited" | "user.activated" | etc.
    entity_type: string;          // "user" | "tenant" | "doctor"
    entity_id: string;
    ip_address: string;
    user_agent: string;
    metadata: object;             // Additional context
  }

  Link: Users_Table â†” Doctors_Table_V2

  // Add to existing Doctors_Table_V2
  {
    doctor_id: string;            // PK (existing)
    user_id: string;              // NEW: FK to Users_Table, GSI: user_id-index
    // ... rest of existing fields
  }

  ---
  2. API ENDPOINTS

  Owner Registration & Authentication

  POST /auth/register-owner          # Create owner user + tenant
  POST /auth/verify-email            # Verify email with 24h token
  POST /auth/signin-owner            # Owner login (email + password)
  POST /legal/accept-terms           # Accept T&C with IP stamp

  Doctor Invitation Flow

  POST /users/invite-doctor          # Owner sends invitation
  GET  /users/validate-invite-token  # Validate invite token (frontend check)
  POST /users/accept-invite          # Doctor activates account
  POST /users/resend-invite          # Resend expired invitation

  User Management

  GET  /users                        # List all users by tenant (with filters)
  PATCH /users/:userId/status        # Change user status
  GET  /users/:userId                # Get user details

  ---
  3. DATA FLOW ARCHITECTURE

  Flow 1: Owner Registration

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STEP 1: Owner Registers                                          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  [Owner Frontend: /register]
      â†“ POST /api/auth/register-owner
      â†“ { email, password, fullName, clinicName, country }

  [Next.js API Route: /api/auth/register-owner]
      â†“ Proxy to AWS API Gateway
      â†“ POST /auth/register-owner

  [API Gateway â†’ Lambda: RegisterOwnerFunction]
      â†“ Hash password (Argon2id)
      â†“ Generate email verification token (24h JWT)
      â†“ Create user record (status: "draft")
      â†“ Create tenant record (status: "draft")
      â†“ Send verification email (Mailgun)
      â†“ Log audit: "owner.registered"
      â† Return { userId, tenantId, message: "Check email" }

  [Owner clicks email verification link]
      â†“ GET /verify-email?token={JWT}

  [Lambda: VerifyEmailFunction]
      â†“ Verify JWT signature + expiry
      â†“ Update user status: "draft" â†’ "incomplete"
      â†“ Update tenant status: "draft" â†’ "incomplete"
      â†“ Log audit: "owner.email_verified"
      â† Return success + redirect to /onboarding

  [Owner completes profile + accepts T&C]
      â†“ POST /legal/accept-terms { userId, ipAddress }

  [Lambda: AcceptTermsFunction]
      â†“ Record consent with IP + timestamp
      â†“ Update user status: "incomplete" â†’ "active"
      â†“ Update tenant status: "incomplete" â†’ "active"
      â†“ Log audit: "owner.terms_accepted"
      â† Owner can now access dashboard

  ---
  Flow 2: Doctor Invitation

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STEP 2: Owner Invites Doctor                                    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  [Owner Dashboard: /users â†’ Invite User]
      â†“ POST /api/users/invite-doctor
      â†“ { email, fullName, role: "doctor" }
      â†“ Authorization: Bearer {ownerJWT}

  [Next.js API Route: /api/users/invite-doctor]
      â†“ Proxy to AWS API Gateway
      â†“ POST /users/invite-doctor

  [API Gateway â†’ Lambda: InviteDoctorFunction]
      â†“ Verify owner JWT
      â†“ Check if email already exists (Users_Table email-index)
      â†“ If exists: Return 409 Conflict
      â†“ Generate single-use invite token (JWT, 24h expiry)
      â†“   Payload: { userId, email, role, tenantId, exp }
      â†“ Create user record:
      â†“   {
      â†“     user_id: UUID,
      â†“     email,
      â†“     full_name,
      â†“     role: "doctor",
      â†“     status: "invited",
      â†“     tenant_id,
      â†“     invite_token: JWT,
      â†“     invite_token_expires: epoch + 24h
      â†“   }
      â†“ Send invitation email via Mailgun:
      â†“   Subject: "InvitaciÃ³n a VITAS - {ClinicName}"
      â†“   Body: Personalized with activation link
      â†“   Link: {FRONTEND_URL}/activate?token={inviteToken}
      â†“ Log audit: "doctor.invited"
      â† Return { userId, message: "Invitation sent" }

  [Owner sees: Status ğŸŸ  Invited in user list]

  ---
  Flow 3: Doctor Activation

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STEP 3: Doctor Activates Account                                â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  [Doctor receives email â†’ clicks activation link]
      â†“ Navigate to /activate?token={inviteToken}

  [Activation Page Frontend]
      â†“ On mount: Validate token
      â†“ GET /api/users/validate-invite-token?token={inviteToken}

  [Next.js API Route â†’ Lambda: ValidateInviteTokenFunction]
      â†“ Verify JWT signature + expiry
      â†“ Check if invite_token matches user record
      â†“ Check if status is "invited" (not already activated)
      â† Return { valid: true, email, fullName } or 400/401

  [If valid, show activation form]
      â†“ Doctor fills:
      â†“   - Password (min 8 chars, 1 upper, 1 lower, 1 number)
      â†“   - Confirm password
      â†“   - Checkbox: Accept Terms & Privacy Policy

  [Doctor submits form]
      â†“ POST /api/users/accept-invite
      â†“ { token: inviteToken, password, acceptedTerms: true }

  [Next.js API Route â†’ Lambda: AcceptInviteFunction]
      â†“ Verify JWT + invite_token
      â†“ Validate password strength (backend)
      â†“ Hash password (Argon2id)
      â†“ Update user record:
      â†“   {
      â†“     password_hash: hashedPassword,
      â†“     status: "invited" â†’ "incomplete",
      â†“     invite_token: null (consumed),
      â†“     invite_token_expires: null,
      â†“     updated_at: now()
      â†“   }
      â†“ Record terms acceptance:
      â†“   Log audit: "doctor.terms_accepted" with IP + timestamp
      â†“ Generate auth JWT (24h):
      â†“   Payload: { userId, email, role: "doctor", tenantId }
      â†“ Log audit: "doctor.activated"
      â† Return { token: authJWT, user: {...} }

  [Frontend receives auth JWT]
      â†“ Store in HTTP-only cookie (via Next.js API route)
      â†“ Auto-login (no manual credentials needed)
      â†“ Redirect to /clinical-profile (onboarding mode)

  ---
  Flow 4: Clinical Profile Completion

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STEP 4: Doctor Completes Clinical Profile                       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  [Doctor lands on /clinical-profile (onboarding mode)]
      â†“ Status: ğŸŸ¡ Incomplete
      â†“ Sidebar hidden, focused UI
      â†“ Profile opens in edit mode

  [Doctor completes form]
      â†“ Personal Data: DOB, gender, address, phone, etc.
      â†“ Professional Data: CMP, RNE, specialty, location, signature

  [Doctor clicks "Save"]
      â†“ POST /api/users/clinical-profile
      â†“ { userId, personalData: {...}, professionalData: {...} }
      â†“ Authorization: Bearer {doctorJWT}

  [Next.js API Route â†’ Lambda: UpdateClinicalProfileFunction]
      â†“ Verify doctor JWT
      â†“ Validate CMP (if profession = Doctor)
      â†“ Create/Update Doctors_Table_V2 record:
      â†“   {
      â†“     doctor_id: UUID,
      â†“     user_id: userId (FK),
      â†“     email: user.email,
      â†“     full_name: user.full_name,
      â†“     speciality: professionalData.specialty,
      â†“     id_number: personalData.documentNumber,
      â†“     phone_number: personalData.phone,
      â†“     profile_picture_url: personalData.signatureUrl (S3),
      â†“     active_for_ai_booking: false (not yet validated),
      â†“     ...
      â†“   }
      â†“ Update user status: "incomplete" â†’ "pending"
      â†“ Log audit: "doctor.profile_completed"
      â† Return success

  [Doctor sees: Status ğŸŸ£ Pending â†’ Awaiting admin validation]
  [Doctor cannot schedule appointments yet]

  ---
  Flow 5: Owner Validation

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STEP 5: Owner Validates Doctor                                  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  [Owner views doctor profile with ğŸŸ£ Pending status]
      â†“ Reviews all professional information

  [Owner clicks "Verify Profile"]
      â†“ POST /api/users/:userId/validate
      â†“ Authorization: Bearer {ownerJWT}

  [Next.js API Route â†’ Lambda: ValidateDoctorFunction]
      â†“ Verify owner JWT + permissions
      â†“ Update user status: "pending" â†’ "active"
      â†“ Update Doctors_Table_V2:
      â†“   { active_for_ai_booking: true }
      â†“ Create PractitionerRole (FHIR):
      â†“   Link: User â†” Specialty â†” Location
      â†“ Log audit: "doctor.validated" with owner IP
      â† Return success

  [Doctor can now receive appointments]
  [Status changes to: ğŸŸ¢ Active]

  ---
  4. FRONTEND COMPONENTS (vitas-client)

  src/app/
  â”œâ”€â”€ (auth)/
  â”‚   â”œâ”€â”€ register/               # Owner registration
  â”‚   â”‚   â””â”€â”€ page.tsx
  â”‚   â”œâ”€â”€ verify-email/           # Email verification
  â”‚   â”‚   â””â”€â”€ page.tsx
  â”‚   â”œâ”€â”€ activate/               # Doctor activation
  â”‚   â”‚   â””â”€â”€ page.tsx
  â”‚   â””â”€â”€ signin/                 # Existing login
  â”‚       â””â”€â”€ page.tsx
  â”œâ”€â”€ (dashboard)/
  â”‚   â”œâ”€â”€ users/                  # User management
  â”‚   â”‚   â”œâ”€â”€ page.tsx            # List users
  â”‚   â”‚   â””â”€â”€ [id]/
  â”‚   â”‚       â””â”€â”€ page.tsx        # User detail + validate
  â”‚   â””â”€â”€ clinical-profile/       # Doctor profile completion
  â”‚       â””â”€â”€ page.tsx
  â”œâ”€â”€ api/
  â”‚   â”œâ”€â”€ auth/
  â”‚   â”‚   â”œâ”€â”€ register-owner/
  â”‚   â”‚   â”‚   â””â”€â”€ route.ts
  â”‚   â”‚   â”œâ”€â”€ verify-email/
  â”‚   â”‚   â”‚   â””â”€â”€ route.ts
  â”‚   â”‚   â””â”€â”€ signin-owner/
  â”‚   â”‚       â””â”€â”€ route.ts
  â”‚   â””â”€â”€ users/
  â”‚       â”œâ”€â”€ invite-doctor/
  â”‚       â”‚   â””â”€â”€ route.ts
  â”‚       â”œâ”€â”€ validate-invite-token/
  â”‚       â”‚   â””â”€â”€ route.ts
  â”‚       â”œâ”€â”€ accept-invite/
  â”‚       â”‚   â””â”€â”€ route.ts
  â”‚       â”œâ”€â”€ clinical-profile/
  â”‚       â”‚   â””â”€â”€ route.ts
  â”‚       â””â”€â”€ [userId]/
  â”‚           â””â”€â”€ validate/
  â”‚               â””â”€â”€ route.ts

  ---
  5. BACKEND LAMBDA FUNCTIONS (vitas-main-stack)

  vitas-main-stack/
  â””â”€â”€ lambda/
      â””â”€â”€ vitas-auth/
          â””â”€â”€ src/
              â”œâ”€â”€ auth/
              â”‚   â”œâ”€â”€ register-owner.ts          # POST /auth/register-owner
              â”‚   â”œâ”€â”€ verify-email.ts            # GET /auth/verify-email
              â”‚   â”œâ”€â”€ signin-owner.ts            # POST /auth/signin-owner
              â”‚   â””â”€â”€ accept-terms.ts            # POST /legal/accept-terms
              â”œâ”€â”€ users/
              â”‚   â”œâ”€â”€ invite-doctor.ts           # POST /users/invite-doctor
              â”‚   â”œâ”€â”€ validate-invite-token.ts   # GET /users/validate-invite-token
              â”‚   â”œâ”€â”€ accept-invite.ts           # POST /users/accept-invite
              â”‚   â”œâ”€â”€ update-clinical-profile.ts # POST /users/clinical-profile
              â”‚   â””â”€â”€ validate-doctor.ts         # POST /users/:userId/validate
              â””â”€â”€ services/
                  â”œâ”€â”€ mailgun.service.ts         # Email sending
                  â”œâ”€â”€ jwt.service.ts             # Token generation/validation
                  â””â”€â”€ audit.service.ts           # Audit logging

  ---
  6. MAILGUN EMAIL TEMPLATES

  Template 1: Owner Email Verification

  Subject: Verifica tu correo - VITAS Clinic

  Hola {fullName},

  Gracias por registrarte en VITAS.

  Por favor, verifica tu correo electrÃ³nico haciendo clic en el siguiente enlace:

  [Verificar Email] â†’ {FRONTEND_URL}/verify-email?token={verificationToken}

  Este enlace expira en 24 horas.

  ---
  VITAS Clinic Team

  Template 2: Doctor Invitation

  Subject: InvitaciÃ³n a VITAS - {ClinicName}

  Hola, Dr. {fullName},

  Has sido invitado por {clinicName} para unirte a VITAS como profesional mÃ©dico.

  Para activar tu cuenta, haz clic en el siguiente enlace:

  [Activar Cuenta] â†’ {FRONTEND_URL}/activate?token={inviteToken}

  Importante:
  â€¢ Este enlace expira en 24 horas
  â€¢ No compartas este correo o enlace con nadie
  â€¢ Al activar, deberÃ¡s crear una contraseÃ±a segura

  Por seguridad, este mensaje cumple con la Ley 29733 de ProtecciÃ³n de Datos Personales.

  ---
  VITAS Clinic Team

  ---
  7. KEY SECURITY FEATURES

  // Password hashing (Argon2id)
  import argon2 from 'argon2';

  async function hashPassword(password: string): Promise<string> {
    return argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4
    });
  }

  // JWT generation (24h expiry)
  import * as jose from 'jose';

  async function generateInviteToken(userId: string, email: string, tenantId: string) {
    return await new jose.SignJWT({
      userId,
      email,
      role: 'doctor',
      tenantId,
      type: 'invite'
    })
      .setProtectedHeader({ alg: 'HS256' })
      .setExpirationTime('24h')
      .setIssuedAt()
      .sign(new TextEncoder().encode(process.env.JWT_SECRET));
  }

  // Audit logging
  async function logAudit(params: {
    userId: string;
    tenantId: string;
    action: string;
    entityType: string;
    entityId: string;
    ipAddress: string;
    metadata?: any;
  }) {
    await dynamodb.put({
      TableName: 'Audit_Logs_Table',
      Item: {
        log_id: uuidv4(),
        timestamp: new Date().toISOString(),
        ...params
      }
    }).promise();
  }

  ---
  ğŸ“Š SUMMARY

  What This Architecture Implements:
  - âœ… Complete user management system (owner + doctor)
  - âœ… Secure invitation flow with single-use tokens
  - âœ… Email verification and activation
  - âœ… Password security (Argon2id)
  - âœ… Audit trail for all state changes
  - âœ… Multi-tenant support (clinic/IPRESS)
  - âœ… Integration with existing Doctors_Table_V2
  - âœ… Follows existing authentication patterns
  - âœ… Mailgun email service integration

  What Gets Created:
  - 3 new DynamoDB tables (Users, Tenants, Audit_Logs)
  - 9 new Lambda functions (auth + user management)
  - 8 new API endpoints
  - 5 new frontend pages/components
  - 2 email templates (Mailgun)

  ---
  Does this architecture align with your vision? Any changes or additional features you'd like to add before I create the implementation plan?